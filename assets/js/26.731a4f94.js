(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{384:function(t,s,e){"use strict";e.r(s);var r=e(44),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"异步编程的背景知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的背景知识"}},[t._v("#")]),t._v(" 异步编程的背景知识")]),t._v(" "),e("p",[t._v("js引擎是基于单线程事件循环的概念构建的，同一时刻只允许一个代码块在执行。所以需要跟踪即将运行的代码，那些代码被放在一个任务队列中，每当一段代码准备执行时都会被添加到任务队列。")]),t._v(" "),e("p",[t._v("每当js引擎中的一段代码结束执行，事件循环会执行队列中的下一个任务，他是js引擎中的一段程序，负责监控代码执行并管理任务队列")]),t._v(" "),e("h3",{attrs:{id:"事件模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[t._v("#")]),t._v(" 事件模型")]),t._v(" "),e("p",[t._v("用户点击按钮或按下键盘上的按键会触发类似onclick这样的事件，它会向任务队列添加一个新任务来响应用户的操作。这是js中最基础的异步编程形式，直到时间触发时才执行事件处理程序，且执行时上下文与定义时的相同。")]),t._v(" "),e("p",[t._v("事件模型适合用于处理简单的交互。")]),t._v(" "),e("h3",{attrs:{id:"回调模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回调模式"}},[t._v("#")]),t._v(" 回调模式")]),t._v(" "),e("p",[t._v("Node.js通过普及回调函数来改进异步编程模型，回调模式与事件模型类似，异步代码都会在未来某个时间点执行。")]),t._v(" "),e("p",[t._v("回调模式中被调用的函数是作为参数传入的。")]),t._v(" "),e("p",[t._v("回调模式比时间模型更灵活，通过回调模式链接多个调用更加容易。（但是容易出现回调地狱问题）")]),t._v(" "),e("h3",{attrs:{id:"promise基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise基础"}},[t._v("#")]),t._v(" promise基础")]),t._v(" "),e("p",[t._v("Promise相当于异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个Promise。")]),t._v(" "),e("h3",{attrs:{id:"promise生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise生命周期"}},[t._v("#")]),t._v(" promise生命周期")]),t._v(" "),e("ul",[e("li",[t._v("进行中\tpending\t此时操作尚未完成\t所以他也是未处理的，一旦异步操作执行结束promise则变为已处理状态。")]),t._v(" "),e("li",[t._v("异步操作成功完成    fulfilled")]),t._v(" "),e("li",[t._v("异步操作未能成功完成   rejected")])]),t._v(" "),e("p",[t._v("所有promise都有then方法，接受两个参数（可选）：")]),t._v(" "),e("ul",[e("li",[t._v("当promise的状态变为fulfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数。")]),t._v(" "),e("li",[t._v("当promise的状态变为rejected时要调用的函数，所有与失败状态相关的附加数据都会传递给这个拒绝函数")])]),t._v(" "),e("p",[t._v("promise的catch方法：只给其传入拒绝处理程序的then方法。")]),t._v(" "),e("p",[e("strong",[t._v("事件在遇到错误时不会主动触发，回调函数每次都要检查错误参数。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);