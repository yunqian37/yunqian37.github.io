(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{389:function(v,_,t){"use strict";t.r(_);var e=t(44),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"函数式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[v._v("#")]),v._v(" 函数式编程")]),v._v(" "),t("p",[v._v("在js中函数作为一等公民使用上非常自由，无论调用它、或者作为参数、或者作为返回值均可。")]),v._v(" "),t("p",[t("strong",[v._v("高阶函数")])]),v._v(" "),t("p",[v._v("高阶函数可以把函数作为参数，或是将函数作为返回值的参数")]),v._v(" "),t("p",[v._v("js中的高阶函数：forEach()、map()、reduce()、reduceRight()、filter()、every()、some()")]),v._v(" "),t("p",[t("strong",[v._v("偏函数用法")])]),v._v(" "),t("p",[v._v("创建一个调用另一个部分\t参数或变量已经预置的函数\t的函数的用法")]),v._v(" "),t("h3",{attrs:{id:"异步编程的优势与难点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的优势与难点"}},[v._v("#")]),v._v(" 异步编程的优势与难点")]),v._v(" "),t("p",[t("strong",[v._v("优势")])]),v._v(" "),t("p",[v._v("基于事件驱动的非阻塞I/O模型，可以使CPU与I？O并不互相依赖等待，让资源更好的利用。对于网络应用：并行使得各个单点之间能够更有效地组织起来。")]),v._v(" "),t("p",[v._v("Node为了解决编程模型中阻塞I/O的性能问题才用了单线程模型")]),v._v(" "),t("p",[v._v("借助异步I/O模型及V8高性能引擎突破单线程的性能瓶颈，让js在后端达到使用价值")]),v._v(" "),t("p",[t("strong",[v._v("难点")])]),v._v(" "),t("ul",[t("li",[v._v("异常处理：将异常作为回调函数的第一个实参传回，如果为空置则表明异步调用没有任何异常抛出。编写异步方法时必须执行调用者传入的回调函数，正确传递回异常供调用者判断")]),v._v(" "),t("li",[v._v("函数嵌套过深")]),v._v(" "),t("li",[v._v("阻塞代码：即延时操作，在统一规划业务逻辑之后可以调用setTimeout()")]),v._v(" "),t("li",[v._v("多线程编程：child_process是基础API，cluster模块是更深层次的应用")]),v._v(" "),t("li",[v._v("异步转同步：")])]),v._v(" "),t("h3",{attrs:{id:"异步编程解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程解决方案"}},[v._v("#")]),v._v(" 异步编程解决方案")]),v._v(" "),t("p",[t("strong",[v._v("事件发布/订阅模式")])]),v._v(" "),t("p",[v._v("事件监听器是一种广泛用于异步编程的模式，是回调函数的事件化。")]),v._v(" "),t("p",[v._v("订阅事件是一个高阶函数的应用，事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。")]),v._v(" "),t("p",[v._v("事件发布/订阅模式自身并无同步异步调用的问题，但是Node中emit()调用多半是伴随事件循环而异步触发的，所以说事件发布/订阅广泛应用于异步编程")]),v._v(" "),t("p",[v._v("事件侦听器模式也是一种钩子(hook)机制，利用钩子导出内部数据或状态给外部调用者。通过这种方式可以使编程者不用关注组件是如何启动和执行的，只需关注在需要的事件点上即可。")]),v._v(" "),t("p",[v._v("Node对于事件发布/订阅的机制做的处理：")]),v._v(" "),t("ul",[t("li",[v._v("如果一个事件添加了超过10个侦听器，将会得到一条警告。因为侦听器过多有可能导致内存泄漏或存在过多占用CPU的情景")]),v._v(" "),t("li",[v._v("EventEmitter会检查是否对error事件添加过侦听器，添加了则会将这个错误交给侦听器处理，否则这个错误将会作为异常抛出")])])])}),[],!1,null,null,null);_.default=r.exports}}]);