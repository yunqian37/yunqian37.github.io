(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{419:function(v,_,t){"use strict";t.r(_);var e=t(44),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"真实dom和其解析流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#真实dom和其解析流程"}},[v._v("#")]),v._v(" 真实DOM和其解析流程")]),v._v(" "),t("p",[v._v("浏览器渲染引擎工作流程：详见 ./Other/从输入URL到页面加载的过程")]),v._v(" "),t("h5",{attrs:{id:"注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[v._v("#")]),v._v(" 注意点")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("DOM树的构建是文档加载完成开始的？")]),v._v(" "),t("ul",[t("li",[v._v("构建DOM树是一个渐进过程，为达到更好的用户体验，渲染引擎回尽快将内容显示在屏幕上，不必等到整个HTML文档解析完成之后才开始构建render树和布局")])])]),v._v(" "),t("li",[t("p",[v._v("Render树是DOM树和CSS样式表构建完毕才开始构建的？")]),v._v(" "),t("ul",[t("li",[v._v("这三个过程在实际进行的时候并不是完全独立的。而是会有交叉，会一边加载、一边解析、以及一遍渲染")])])]),v._v(" "),t("li",[t("p",[v._v("CSS的解析注意点：")]),v._v(" "),t("ul",[t("li",[v._v("CSS的解析是从右向左逆向解析的，嵌套标签越多解析越慢")])])]),v._v(" "),t("li",[t("p",[v._v("JS操作真实DOM的代价：")]),v._v(" "),t("ul",[t("li",[v._v("原生操作DOM时浏览器会从构建DOM树开始从头到尾执行一遍流程")]),v._v(" "),t("li",[v._v("操作DOM的代价是昂贵的，频繁操作会出现页面卡顿现象，影响用户体验")]),v._v(" "),t("li",[v._v("例：一次操作中需要更新10个DOM节点，浏览器会重复执行10次")])])])]),v._v(" "),t("h1",{attrs:{id:"虚拟dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[v._v("#")]),v._v(" 虚拟DOM")]),v._v(" "),t("p",[t("strong",[v._v("虚拟DOM：")]),v._v(" 通过JS对象模拟出来的DOM节点，domDiff是通过特定的算法计算出来一次操作所带来DOM变化")]),v._v(" "),t("p",[t("strong",[v._v("优点：")]),v._v(" 可以提高代码的性能下限，并极大优化大量操作DOM时产生的新能损耗（虚拟DOM操作不一定更快）\t\t\t 提升渲染性能、具有跨平台优势、提高效率")]),v._v(" "),t("p",[v._v("页面的更新可以先全部反映在js对象（虚拟DOM）上，等更新完成后再将最终的JS对象映射成正式的DOM交由浏览器去绘制")]),v._v(" "),t("p",[v._v("例：一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM。而是将10更新的diff内容保存到本地一个js对象中，最终将这个js的对象一次性给DOM树，再进行后续操作。避免大量不必要的计算量")]),v._v(" "),t("h1",{attrs:{id:"虚拟dom与vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom与vue"}},[v._v("#")]),v._v(" 虚拟DOM与VUE")]),v._v(" "),t("p",[v._v("虚拟DOM在vue.js中主要做了两件事：")]),v._v(" "),t("ul",[t("li",[v._v("提供与真实DOM节点所对应的虚拟节点VNode")]),v._v(" "),t("li",[v._v("将新旧虚拟节点进行对比，然后更新试图")])]),v._v(" "),t("p",[t("strong",[v._v("VNode：")])]),v._v(" "),t("ul",[t("li",[v._v("本质上是js中一个普通的对象，是从VNode类实例化的对象。用js对象来描述一个真实DOM元素的话那么该DOM元素上的所有属性在VNode这个对象上都存在对应的属性")]),v._v(" "),t("li",[v._v("也可以理解成节点描述对象，它描述了应该怎样去创建真实的DON节点")]),v._v(" "),t("li",[v._v("表示一个真实的DOM元素，所有真实的DOM节点都使用VNode创建并插入到页面中")]),v._v(" "),t("li",[v._v("VNode是试图是一一对应的，可以把VNode理解成js对象版本的DOM元素")]),v._v(" "),t("li",[v._v("渲染视图的过程是先创建VNode，然后再使用VNode去生成真实的DOM元素。最好插入页面渲染视图")])]),v._v(" "),t("p",[t("strong",[v._v("VNode作用：")])]),v._v(" "),t("p",[v._v("可以将上一次渲染视图时所创建的VNode缓存起来，之后每当需要重新渲染视图时将新创建的VNode和上一次缓存的VNode进行对比，基于不一样的地方进行修改")]),v._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6844903895467032589"}},[v._v("深入剖析：Vue核心之虚拟DOM")])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6997579802215448606"}},[v._v("Vue 虚拟 DOM 搞不懂？这篇文章帮你彻底搞定虚拟 DOM")])])])}),[],!1,null,null,null);_.default=s.exports}}]);